name: Rust CI/CD

on:
  push:
    branches: [ "main", "develop" ]
  pull_request:
    branches: [ "main" ]
  release:
    types: [created]

env:
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: full

jobs:
  # Job de validaÃ§Ã£o (para PRs e pushes)
  validate:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout cÃ³digo
      uses: actions/checkout@v4
    
    - name: Setup Rust
      uses: dtolnay/rust-toolchain@stable
      with:
        toolchain: stable
        components: clippy, rustfmt
    
    - name: Cache dependÃªncias
      uses: actions/cache@v4
      with:
        path: |
          ~/.cargo/registry
          ~/.cargo/git
          target
        key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
        restore-keys: |
          ${{ runner.os }}-cargo-
    
    - name: Build de desenvolvimento
      run: cargo build --verbose
    
    - name: Executar testes
      run: cargo test --verbose -- --nocapture
    
    - name: Executar Clippy
      run: cargo clippy -- -D warnings
    
    - name: Verificar formataÃ§Ã£o
      run: cargo fmt -- --check

  # Job de build release (sÃ³ para main e releases)
  build-release:
    needs: validate  # Depende do job validate
    if: github.event_name == 'push' && github.ref == 'refs/heads/main' || github.event_name == 'release'
    runs-on: ubuntu-latest
    
    strategy:
      matrix:
        target: [x86_64-unknown-linux-gnu]
        # Adicione mais targets se necessÃ¡rio:
        # - x86_64-pc-windows-msvc
        # - x86_64-apple-darwin
        # - aarch64-unknown-linux-gnu
    
    steps:
    - name: Checkout cÃ³digo
      uses: actions/checkout@v4
    
    - name: Setup Rust
      uses: dtolnay/rust-toolchain@stable
      with:
        toolchain: stable
        targets: ${{ matrix.target }}
    
    - name: Cache dependÃªncias
      uses: actions/cache@v4
      with:
        path: |
          ~/.cargo/registry
          ~/.cargo/git
          target
        key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}-${{ matrix.target }}
    
    - name: Build release
      run: |
        cargo build --release --target ${{ matrix.target }} --verbose
        # Verifica se o binÃ¡rio foi criado
        if [ -f "target/${{ matrix.target }}/release/$(cargo metadata --no-deps --format-version 1 | jq -r '.packages[0].name')" ]; then
          echo "âœ… Build realizado com sucesso"
        else
          echo "âŒ BinÃ¡rio nÃ£o encontrado"
          ls -la target/${{ matrix.target }}/release/
          exit 1
        fi
    
    - name: Extrair nome do binÃ¡rio
      id: get-binary-name
      run: |
        BINARY_NAME=$(cargo metadata --no-deps --format-version 1 | jq -r '.packages[0].name')
        echo "binary_name=$BINARY_NAME" >> $GITHUB_OUTPUT
        echo "VersÃ£o: $(cargo metadata --no-deps --format-version 1 | jq -r '.packages[0].version')"
    
    - name: Preparar artifacts
      run: |
        BINARY_NAME="${{ steps.get-binary-name.outputs.binary_name }}"
        TARGET="${{ matrix.target }}"
        
        # Cria diretÃ³rio para artifacts
        mkdir -p artifacts
        
        # Copia e renomeia o binÃ¡rio
        if [ -f "target/$TARGET/release/$BINARY_NAME" ]; then
          cp "target/$TARGET/release/$BINARY_NAME" "artifacts/${BINARY_NAME}-${TARGET}"
          chmod +x "artifacts/${BINARY_NAME}-${TARGET}"
        elif [ -f "target/$TARGET/release/$BINARY_NAME.exe" ]; then
          cp "target/$TARGET/release/$BINARY_NAME.exe" "artifacts/${BINARY_NAME}-${TARGET}.exe"
        fi
        
        # Lista artifacts gerados
        echo "ðŸ“¦ Artifacts gerados:"
        ls -la artifacts/
    
    - name: Upload artifacts para workflow
      uses: actions/upload-artifact@v4
      with:
        name: binaries-${{ matrix.target }}
        path: artifacts/
        retention-days: 7
    
    # Upload para GitHub Releases (sÃ³ quando uma release Ã© criada)
    - name: Upload para GitHub Release
      if: github.event_name == 'release'
      uses: softprops/action-gh-release@v1
      with:
        files: artifacts/*
        draft: false
        prerelease: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    
    # Cria um artifact com informaÃ§Ãµes da build
    - name: Criar arquivo de versÃ£o
      run: |
        echo "Build: ${{ github.run_number }}" > build-info.txt
        echo "Commit: ${{ github.sha }}" >> build-info.txt
        echo "Data: $(date)" >> build-info.txt
        echo "Target: ${{ matrix.target }}" >> build-info.txt
        echo "VersÃ£o: $(cargo metadata --no-deps --format-version 1 | jq -r '.packages[0].version')" >> build-info.txt
        
        # Upload do arquivo de versÃ£o
        cp build-info.txt artifacts/
    
    # NotificaÃ§Ã£o opcional (Slack, Discord, etc.)
    - name: Notificar sucesso
      if: success()
      run: |
        echo "âœ… Build #${{ github.run_number }} concluÃ­da com sucesso!"
        echo "ðŸ“¦ BinÃ¡rios disponÃ­veis na aba Artifacts"
        if [ "${{ github.event_name }}" = "release" ]; then
          echo "ðŸš€ Release publicado: ${{ github.event.release.tag_name }}"
        fi

  # Job para limpeza (opcional)
  cleanup:
    needs: [validate, build-release]
    if: always()
    runs-on: ubuntu-latest
    steps:
    - name: Limpar cache se falhou
      if: failure()
      run: |
        echo "ðŸ§¹ Limpando cache devido a falha..."
        # Remove o cache da execuÃ§Ã£o atual
        echo "Cache-ID: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}"
      # Nota: O GitHub Actions gerencia automaticamente o cache,
      # mas vocÃª pode forÃ§ar limpeza se necessÃ¡rio
